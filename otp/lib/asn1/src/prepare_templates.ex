defmodule :m_prepare_templates do
  use Bitwise

  def gen_asn1ct_rtt(ms) do
    {:ok, fd} = :file.open('asn1ct_rtt.erl', [:write])

    :io.format(fd, '%% Generated by ~s. DO NOT EDIT THIS FILE.\n%%\n%% Input files:\n', [
      :prepare_templates
    ])

    for m <- ms do
      :io.put_chars(fd, ['%%  ', m, ?\n])
    end

    :io.nl(fd)

    :io.put_chars(
      fd,
      '-module(asn1ct_rtt).\n-export([assert_defined/1,dependencies/1,code/0]).\n\n'
    )

    forms =
      :lists.sort(
        :lists.append(
          for m <- ms do
            abstract(m)
          end
        )
      )

    exp = :lists.sort(exports(forms))
    defined(fd, exp)
    :io.nl(fd)
    calls = calls(forms)
    r = :sofs.relation(calls)
    fam0 = :sofs.relation_to_family(r)
    fam = :sofs.to_external(fam0)
    dependencies(fd, fam)
    :io.nl(fd)

    funcs =
      for {m, {:function, _, f, a, _} = func} <- forms do
        bin =
          :erlang.list_to_binary([
            ?\n
            | :erl_pp.function(func)
          ])

        {{m, f, a}, bin}
      end

    :io.format(fd, 'code() ->\n~p.\n\n', [funcs])
    :ok = :file.close(fd)
    :erlang.halt(0)
  end

  def gen_asn1ct_eval([file]) do
    output = :filename.rootname(file, '.funcs') ++ '.erl'
    {:ok, fd} = :file.open(output, [:write])
    {:ok, funcs} = :file.consult(file)
    :asn1ct_func.start_link()

    for mFA <- funcs do
      :asn1ct_func.need(mFA)
    end

    :io.format(fd, '%% Generated by ~s. DO NOT EDIT THIS FILE.\n%%\n%% Input file: ~s\n\n', [
      :prepare_templates,
      file
    ])

    :io.format(fd, '-module(~s).\n', [:filename.rootname(file)])
    gen_asn1ct_eval_exp(fd, funcs)
    :asn1ct_func.generate(fd)
    :ok = :file.close(fd)
    :erlang.halt(0)
  end

  defp gen_asn1ct_eval_exp(fd, funcs) do
    :io.put_chars(fd, '-export([')
    gen_asn1ct_eval_exp_1(fd, funcs, '')
    :io.put_chars(fd, ']).\n')
  end

  defp gen_asn1ct_eval_exp_1(fd, [{_, f, a} | t], sep) do
    :io.put_chars(fd, sep)
    :io.format(fd, '~p/~p', [f, a])
    gen_asn1ct_eval_exp_1(fd, t, ',\n')
  end

  defp gen_asn1ct_eval_exp_1(_, [], _) do
    :ok
  end

  defp defined(fd, [h | t]) do
    :io.format(fd, 'assert_defined(~p) -> ok', [h])

    case t do
      [] ->
        :io.put_chars(fd, '.\n')

      [_ | _] ->
        :io.put_chars(fd, ';\n')
        defined(fd, t)
    end
  end

  defp dependencies(fd, [{k, v} | t]) do
    :io.format(fd, 'dependencies(~p) ->\n~p;\n', [k, v])
    dependencies(fd, t)
  end

  defp dependencies(fd, []) do
    :io.put_chars(fd, 'dependencies(_) -> [].\n')
  end

  defp abstract(file) do
    {:ok, {m0, [{:abstract_code, abstract}]}} =
      :beam_lib.chunks(
        file,
        [:abstract_code]
      )

    {:raw_abstract_v1, forms} = abstract
    m = module(m0)

    for f <- forms do
      {m, f}
    end
  end

  defp module(m0) do
    'asn1rtt_' ++ m = :erlang.atom_to_list(m0)
    :erlang.list_to_atom(m)
  end

  defp exports([{m, {:attribute, _, :export, l}} | t]) do
    for {f, a} <- l do
      {m, f, a}
    end ++ exports(t)
  end

  defp exports([_ | t]) do
    exports(t)
  end

  defp exports([]) do
    []
  end

  defp calls([{m, {:function, _, f, a, body}} | t]) do
    mFA = {m, f, a}

    case find_calls(body, m) -- [mFA] do
      [] ->
        calls(t)

      [_ | _] = calls ->
        for callee <- calls do
          {mFA, callee}
        end ++ calls(t)
    end
  end

  defp calls([_ | t]) do
    calls(t)
  end

  defp calls([]) do
    []
  end

  defp find_calls([{:call, _, {:atom, _, f}, args} | t], m) do
    calls = find_calls(args, m) ++ find_calls(t, m)
    arity = length(args)

    case is_bif(f, arity) do
      false ->
        [{m, f, arity} | calls]

      true ->
        calls
    end
  end

  defp find_calls([{:fun, _, {:function, f, a}} | t], m) do
    [{m, f, a} | find_calls(t, m)]
  end

  defp find_calls([h | t], m) do
    find_calls(h, m) ++ find_calls(t, m)
  end

  defp find_calls(tuple, m) when is_tuple(tuple) do
    find_calls(:erlang.tuple_to_list(tuple), m)
  end

  defp find_calls(_, _) do
    []
  end

  defp is_bif(f, arity) do
    :erl_internal.bif(f, arity)
  end
end
