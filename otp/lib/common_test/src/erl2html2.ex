defmodule :m_erl2html2 do
  use Bitwise

  def convert([], _Dest, _InclPath) do
    :ok
  end

  def convert(file, dest, inclPath) do
    encoding = encoding(file)

    header = [
      '<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">\n<!-- autogenerated by \'',
      :erlang.atom_to_list(:erl2html2),
      '\'. -->\n<html>\n<head>\n<meta http-equiv="Content-Type" content="text/html;charset=',
      html_encoding(encoding),
      '"/></meta>\n<title>',
      to_raw_list(
        file,
        encoding
      ),
      '</title>\n</head>\n\n<body bgcolor="white" text="black" link="blue" vlink="purple" alink="red">\n'
    ]

    convert(file, dest, inclPath, header)
  end

  def convert(file, dest, inclPath, header) do
    case parse_file(file, inclPath) do
      {:ok, functions} ->
        case :file.open(file, [:raw, {:read_ahead, 10000}]) do
          {:ok, sFd} ->
            case :file.open(dest, [:write, :raw]) do
              {:ok, dFd} ->
                :ok = :file.write(dFd, [header, '<pre>\n'])
                _Lines = build_html(sFd, dFd, encoding(file), functions)
                :ok = :file.write(dFd, ['</pre>\n', footer(), '</body>\n</html>\n'])
                :ok = :file.close(sFd)
                :ok = :file.close(dFd)
                :ok

              error ->
                error
            end

          error ->
            error
        end

      error ->
        error
    end
  end

  defp parse_file(file, inclPath) do
    case :epp.open(file, inclPath, []) do
      {:ok, epp} ->
        try do
          parse_preprocessed_file(epp, file, false)
        catch
          _, {:error, _Reason, true} ->
            parse_non_preprocessed_file(file)

          _, {:error, _Reason, false} ->
            {:ok, []}
        else
          forms ->
            :epp.close(epp)
            {:ok, forms}
        end

      error = {:error, _} ->
        error
    end
  end

  defp parse_preprocessed_file(epp, file, inCorrectFile) do
    case :epp.parse_erl_form(epp) do
      {:ok, form} ->
        case form do
          {:attribute, _, :file, {^file, _}} ->
            parse_preprocessed_file(epp, file, true)

          {:attribute, _, :file, {_OtherFile, _}} ->
            parse_preprocessed_file(epp, file, false)

          {:function, l, f, a, cs} when inCorrectFile ->
            {cLs, lastCL} = find_clause_lines(cs, [])

            [
              {:erlang.atom_to_list(f), a, get_line(l), lastCL}
              | tl(cLs)
            ] ++ parse_preprocessed_file(epp, file, true)

          _ ->
            parse_preprocessed_file(epp, file, inCorrectFile)
        end

      {:error, reason = {_L, :epp, {:undefined, _Macro, :none}}} ->
        throw({:error, reason, inCorrectFile})

      {:error, _Reason} ->
        parse_preprocessed_file(epp, file, inCorrectFile)

      {:warning, _} ->
        parse_preprocessed_file(epp, file, inCorrectFile)

      {:eof, _Location} ->
        []
    end
  end

  defp parse_non_preprocessed_file(file) do
    case :file.open(file, []) do
      {:ok, epp} ->
        forms = parse_non_preprocessed_file(epp, file, 1)
        :ok = :file.close(epp)
        {:ok, forms}

      error = {:error, _E} ->
        error
    end
  end

  defp parse_non_preprocessed_file(epp, file, location) do
    case :epp_dodger.parse_form(epp, location) do
      {:ok, tree, location1} ->
        try do
          :erl_syntax.revert(tree)
        catch
          _, _ ->
            parse_non_preprocessed_file(epp, file, location1)
        else
          {:function, l, f, a, cs} ->
            {cLs, lastCL} = find_clause_lines(cs, [])

            [
              {:erlang.atom_to_list(f), a, get_line(l), lastCL}
              | tl(cLs)
            ] ++ parse_non_preprocessed_file(epp, file, location1)

          _ ->
            parse_non_preprocessed_file(epp, file, location1)
        end

      {:error, _E, location1} ->
        parse_non_preprocessed_file(epp, file, location1)

      {:eof, _Location} ->
        []
    end
  end

  defp get_line(anno) do
    :erl_anno.line(anno)
  end

  defp find_clause_lines([{:clause, cL, _Params, _Op, exprs}], cLs) do
    case classify_exprs(exprs) do
      {:anno, anno} ->
        {:lists.reverse([{:clause, get_line(cL)} | cLs]), get_line(anno)}

      {:tree, exprs1} ->
        find_clause_lines(
          [{:clause, cL, :undefined, :undefined, exprs1}],
          cLs
        )

      :unknown ->
        {:lists.reverse([{:clause, get_line(cL)} | cLs]), get_line(cL)}
    end
  end

  defp find_clause_lines(
         [{:clause, cL, _Params, _Op, _Exprs} | cs],
         cLs
       ) do
    find_clause_lines(cs, [{:clause, get_line(cL)} | cLs])
  end

  defp classify_exprs(exprs) do
    case :erlang.tuple_to_list(:lists.last(exprs)) do
      [:macro, {_var, anno, _MACRO} | _] ->
        {:anno, anno}

      [t, exprAnno | exprs1] ->
        case :erl_anno.is_anno(exprAnno) do
          true ->
            {:anno, exprAnno}

          false when t === :tree ->
            {:tree, exprs1}

          false ->
            :unknown
        end
    end
  end

  defp build_html(sFd, dFd, encoding, funcsAndCs) do
    build_html(sFd, dFd, encoding, :file.read_line(sFd), 1, funcsAndCs, false, :undefined)
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, lastL, funcsAndCs, _IsFuncDef, {f, lastL}) do
    lastLineLink =
      :test_server_ctrl.uri_encode(
        f ++ '-last_expr',
        :utf8
      )

    :ok =
      :file.write(
        dFd,
        ['<a name="', to_raw_list(lastLineLink, enc), '"/>']
      )

    build_html(sFd, dFd, enc, {:ok, str}, lastL, funcsAndCs, true, :undefined)
  end

  defp build_html(
         sFd,
         dFd,
         enc,
         {:ok, str},
         l0,
         [{f, a, l0, lastL} | funcsAndCs],
         _IsFuncDef,
         _FAndLastL
       ) do
    fALink =
      :test_server_ctrl.uri_encode(
        f ++ '-' ++ :erlang.integer_to_list(a),
        :utf8
      )

    :ok = :file.write(dFd, ['<a name="', to_raw_list(fALink, enc), '"/>'])
    build_html(sFd, dFd, enc, {:ok, str}, l0, funcsAndCs, true, {f, lastL})
  end

  defp build_html(
         sFd,
         dFd,
         enc,
         {:ok, str},
         l,
         [{:clause, l} | funcsAndCs],
         _IsFuncDef,
         fAndLastL
       ) do
    build_html(sFd, dFd, enc, {:ok, str}, l, funcsAndCs, true, fAndLastL)
  end

  defp build_html(sFd, dFd, enc, {:ok, str}, l, funcsAndCs, isFuncDef, fAndLastL) do
    lStr = line_number(l)
    str1 = line(str, isFuncDef)
    :ok = :file.write(dFd, [lStr, str1])
    build_html(sFd, dFd, enc, :file.read_line(sFd), l + 1, funcsAndCs, false, fAndLastL)
  end

  defp build_html(_SFd, _DFd, _Enc, :eof, l, _FuncsAndCs, _IsFuncDef, _FAndLastL) do
    l
  end

  defp line_number(l) do
    lStr = :erlang.integer_to_list(l)

    pred =
      case length(lStr) do
        length when length < 5 ->
          :lists.duplicate(5 - length, ?\s)

        _ ->
          []
      end

    ['<a name="', lStr, '"/>', pred, lStr, ': ']
  end

  defp line(str, isFuncDef) do
    str1 = htmlize(str)
    possibly_enhance(str1, isFuncDef)
  end

  defp htmlize([?< | str]) do
    [?&, ?l, ?t, ?; | htmlize(str)]
  end

  defp htmlize([?> | str]) do
    [?&, ?g, ?t, ?; | htmlize(str)]
  end

  defp htmlize([?& | str]) do
    [?&, ?a, ?m, ?p, ?; | htmlize(str)]
  end

  defp htmlize([?" | str]) do
    [?&, ?q, ?u, ?o, ?t, ?; | htmlize(str)]
  end

  defp htmlize([ch | str]) do
    [ch | htmlize(str)]
  end

  defp htmlize([]) do
    []
  end

  defp possibly_enhance(str, true) do
    case :lists.splitwith(
           fn
             ?( ->
               false

             _ ->
               true
           end,
           str
         ) do
      {_, []} ->
        str

      {f, a} ->
        ['<b>', f, '</b>', a]
    end
  end

  defp possibly_enhance([?% | _] = str, _) do
    ['<i>', str -- '\n', '</i>', '\n']
  end

  defp possibly_enhance([?- | _] = str, _) do
    possibly_enhance(str, true)
  end

  defp possibly_enhance(str, false) do
    str
  end

  defp footer() do
    ''
  end

  defp encoding(file) do
    case :epp.read_encoding(file) do
      :none ->
        :epp.default_encoding()

      e ->
        e
    end
  end

  defp html_encoding(:latin1) do
    'iso-8859-1'
  end

  defp html_encoding(:utf8) do
    'utf-8'
  end

  defp to_raw_list(x, :latin1) when is_list(x) do
    x
  end

  defp to_raw_list(x, :utf8) when is_list(x) do
    :erlang.binary_to_list(:unicode.characters_to_binary(x))
  end
end
